Внешний контроль прав пользователей для старых конфигураций 1С:Предприятие

Используется такая структура JSON запроса к серверу Odoo:

- Тип объекта (набор значений определяется в коде модуля)
- Имя пользователя (как в базе данных 1С)
- Дата, связанная с объектом (дата документа, произвольная дата - неважно. Дата, которая будет сравниваться)
- Режим (всегда "write", зарезервирован на будущее)
- дополнительные параметры в словаре

структура дополнительных параметров:
- regEx ключ, всегда True, зарезервирован на будущее
- testType ключ, "match" или "search"
- testValue ключ, собственно проверяемое значение

Правила применяются к группам пользователей. Группы пользователей в модуле существуют сами по себе и к группам пользователей Odoo отношения не имеют. Пользователи могут быть включены в несколько групп одновременно.

Правила запрещают или разрешают действие, как показано на Диаграмме 1. Также у правил есть приоритет, который может быть полезен в некоторых сценариях. Результат проверки правила помещается в словарь, - Приоритет, Тип правила, результат проверки. Словари, в свою очередь, помещаются в списки.
Затем, анализируя получившийся список, принимается решение, разрешить или запретить действие (в соответствии с Диаграммой 2).

Модуль является экспериментальным, поэтому, несмотря на работоспособность, для применения в рабочих базах данных не рекомендуется без предварительного широкого тестирования. Код модуля не оптимизирован ради удобства отладки.

Пример обработки для 1С - для обычных форм по понятным причинам.
Просмотр mermaid-диаграмм: https://mermaid.live/

Пример запроса JSON, формат:

{
"jsonrpc": "2.0",
"method": "call",
"params": {
"args": [
"<odoo_database_name>",
<user_id> (Здесь внутренний ID пользователя. У admin, например, 2 в чистой базе),
"<passwd>",
"acs1crules.usr1crules",
"extCallCheck",
[],
"DocProductsSaleOrder",
"Dennis",
"2023-06-17",
"write",
{
"regExp": true,
"testType": "match",
"testValue": "CDB00161"
}
],
"method": "execute",
"service": "object"
},
"id": null
}


Диаграмма 1
```mermaid
flowchart TD
    A([Проверка текущего правила]) --> B{Это</br>запрещающее</br>правило?}
    B -->|No| AllowRuleCheck{Тип правила -</br>разрешение</br>на запись?}
    AllowRuleCheck --> |Yes|WriteEnabledCheckAllowRule["`Если поле ruleNumValue > 0, то результат проверки установить True (правило выполняется, действие **разрешено**)`"]
    AllowRuleCheck --> |No|CheckObjectDateAllowRule["`Если дата в параметре **позже чем (или равна)** дате в правиле, тогда установить результат проверки в True (правило выполняется, действие **разрешено**)`"]
    WriteEnabledCheckAllowRule --> MainCheckFinished
    CheckObjectDateAllowRule --> MainCheckFinished
    %% Для правил с типом "Разрешение" результат проверки True означает разрешение операции, для правил с типом "Запрет" - запрет операции соответственно
    B -->|Yes| C{Есть ли</br>дополнительные</br>параметры?}
    C -->|No| SimpleChecks{Тип правила -</br>разрешение</br>на запись?}
    SimpleChecks -->|Yes|WriteEnabledCheckDenyRule["`Если поле ruleNumValue > 0 то результат проверки установить True (правило выполняется, действие **запрещено**)`"]
    SimpleChecks -->|No|CheckObjectDateDenyRule["`Если дата в параметре **раньше** чем дата в правиле, то результат проверки установить True (правило выполняется, действие **запрещено**)`"]
    C -->|Yes| D{Проверять</br>условие методом</br>RegEx match?}
    D -->|Yes| G["`Проверить testValue на точное совпадение с полем ruleStrValue правила. Регистр игнорируется.`"]
    D -->|No| E["`Проверить testValue на соответствие шаблону в поле ruleStrValue, правила составления шаблона - для метода RegEx search. Регистр игнорируется.`"]
    G --> MainCheckFinished
    E --> MainCheckFinished(["`Поместить результат в словарь, словарь добавить в список. Перейти к следующему правилу.`"])
    WriteEnabledCheckDenyRule --> MainCheckFinished
    CheckObjectDateDenyRule --> MainCheckFinished
```
Диаграмма 2
```mermaid
flowchart TD
CStart(["Анализ результатов проверок правил."])-->cursorInit["`курсор: приоритет = 0, значение = False`"]
cursorInit -->|Перебор элементов| A{{"currResult of checkResults"}}
A--> B{currResult -</br>результат правила</br>запрещающего типа?}
B -->|No| A
B -->|Yes| cursorCheck{Приоритет</br>текущего результата</br>такой же, что и у</br>курсора?}
cursorCheck-->|Yes| cursorSet["`Установить значение курсора: <текущее значение курсора> **OR** currResult.value (если хоть одно из правил запрещает операцию (результат проверки правила = True), то операция запрещена) `"]
cursorCheck-->|No| C{Приоритет</br>текущего результата</br>выше, чем у</br>курсора?}
C-->|Yes| D[Установить приоритет</br>и значение курсора как</br>у текущего результата]
D--> A
C-->|No| A
cursorSet-->A
A-->|Цикл по результатам правил запрещающего типа завершен,</br>следующий цикл по правилам разрешающего типа. </br> перебор элементов| E1{{"currResult of checkResults"}}
E1--> F{currResult -</br>результат правила</br>запрещающего типа?}
F-->|No| E1
F-->|Yes| cursorCheckPriority{Приоритет</br>текущего результата</br>такой же, что и у</br>курсора?}
cursorCheckPriority-->|Yes| cursorCheck3{"`Операция (**NOT** <текущее значение курсора> **AND NOT** currResult.value) истинна?`"}
cursorCheck3-->|Yes| cursorSet3_1["`Установить значение курсора в True (означает, что приоритет правила разрешающего типа выше и оно запрещает операцию)`"]
cursorCheck3-->|No| cursorSet3_2["`Установить значение курсора в (<текущее значение курсора> **AND NOT** currResult.value) (запрещает действие только в том случае, если оба правила запрещают)`"]
cursorCheckPriority-->|No| cursorCheck2{Приоритет</br>текущего результата</br>выше, чем у курсора?}
cursorCheck2-->|Yes| cursorSet4[Установить приоритет</br>и значение курсора как</br>у текущего результата]
cursorCheck2-->|No| E1
cursorSet4--> E1
cursorSet3_1--> E1
cursorSet3_2--> E1
E1==>|Конец цикла| CEnd(["`Анализ завершен,</br>**вернуть текущее значение курсора.**`"])
```
